{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Langage C - Notebook C2\n",
    "## Allocation dynamique\n",
    "\n",
    "#### Katia Jaffrès-Runser, Xavier Crégut\n",
    "\n",
    "Toulouse INP - ENSEEIHT,\n",
    "\n",
    "1ère année, Dept. Sciences du Numérique, 2020-2021."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## 1. Déroulement du cours\n",
    "---\n",
    "Ce cours se déroule sur 6 séances de TP. \n",
    "\n",
    "- Lors des trois premières séances, vous avez suivi le sujet C1 sous la forme d'un notebook Jupyter.\n",
    "- Lors des trois dernières séances, vous suivrez deux autres notebook Jupyter, C2 et C3, à votre rythme.\n",
    "\n",
    "Chaque sujet, C1, C2 et C3, se termine par un exercice Bilan à rendre via votre dépot SVN. Les échéances sont indiquées sur Moodle. Les 3 exercices bilans sont notés, et leur moyenne fournit une note d'exercices.\n",
    "\n",
    "Vous aurez, en fin de cours, un QCM d'une heure. La note finale est une moyenne des deux notes (QCM et exercices rendus)."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## 2. Objectifs \n",
    "Ce cours, sous la forme de notebooks Jupyter et d'un ensemble d'exercices à réaliser en TP, a pour objectif de vous présenter les spécificités de la programmation en langage C. Il se base sur vos acquis du cours de Programmation Impérative en algorithmique et vous détaille les éléments du langage C nécessaires à la production d'un programme en C. \n",
    "\n",
    "Un support de cours PDF vous est également fournit sur Moodle : [Cours C](http://moodle-n7.inp-toulouse.fr/pluginfile.php/49240/mod_resource/content/5/LangageC_poly.pdf)."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## 3. Plan du sujet C2. \n",
    "---\n",
    "\n",
    "Ce sujet se focalise sur l'allocation dynamique de mémoire en C. Il vous présente :\n",
    "\n",
    "- Les principaux allocateurs de mémoire, et leur utilisation. \n",
    "- La libération de mémoire, et son utilisation.\n",
    "- La distinction entre manipulation d'un tableau statique et dynamique en C\n",
    "- Le sous-programme de réallocation de mémoire\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "---\n",
    "---\n",
    "---"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Rappel : Jupyter notebook\n",
    "\n",
    "Le support de cours que vous lisez est un notebook Jupyter. Pour visualiser le notebook, lancer l'editeur web avec la commande  \n",
    "> `jupyter-notebook`\n",
    "\n",
    "et rechercher le fichier dans l'arborescence. Le fichier est édité dans votre navigateur Web par défaut. L'enregistrement est automatique (`CTRL S` pour le forcer). \n",
    "\n",
    "Pour fermer votre fichier, il faut fermer le navigateur et terminer le processus serveur qui s'exécute dans le terminal (`CTRL C`, puis `y`).\n",
    "\n",
    "> __Important__ : \n",
    "> - Pour faire fonctionner le kernel C de jupyter notebook, il faut, avant une __première utilisation__ de Notebook, lancer la commande suivante dans un `Terminal` : \n",
    "\n",
    "> `install_c_kernel --user`\n",
    "\n",
    "\n",
    "Ce notebook se compose de cellules présentant soit :\n",
    "- Des éléments de cours, au format [Markdown](https://fr.wikipedia.org/wiki/Markdown). Ce langage est traduit en HTML pour un affichage aisé quand on clique sur la flèche `Exécuter (run)` et que la cellule est active.\n",
    "- Du code en Langage C (ou Python, ou autre..). Pour compiler et exécuter le code écrit dans la cellule active, on clique sur la flèche `Exécuter (run)`. Si la compilation se déroule sans erreur ni avertissement, le programme est exécuté et les sorties sont affichées en bas de la cellule. Si ce n'est pas le cas, les avertissements et warnings sont affichés en bas de la cellule. \n",
    "\n",
    "En double-cliquant sur une cellule, on peut éditer son contenu. \n",
    "Vous pouvez ainsi : \n",
    "- Editer une cellule markdown pour y intégrer vos propres notes. \n",
    "- Modifier les programmes pour répondre aux questions et exercices proposés.\n",
    "\n",
    "Il est possible d'exporter votre travail en PDF, HTML, etc. Il est aussi possible d'afficher les numéros de ligne dans le menu __Affichage__.\n",
    "\n",
    "Le programme dans la cellule suivante s'exécute sans erreur. Vous pouvez \n",
    "- le tester en l'exécutant. \n",
    "- y introduire une erreur (suppression d'un point-virgule par exemple) pour observer la sortie du compilateur.  "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "#include <stdlib.h> \n",
    "#include <stdio.h>\n",
    "int main(){\n",
    "    printf(\"******************************\\n\");\n",
    "    printf(\"******** Langage C ***********\\n\");\n",
    "    printf(\"******************************\\n\");\n",
    "    return EXIT_SUCCESS;\n",
    "}"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "---\n",
    "---\n",
    "---"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## 4. Allocation dynamique de mémoire"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### 4.1 Structure de la mémoire\n",
    "La mémoire vive de votre ordinateur est structurée en différentes parties : \n",
    "- __Le mémoire statique__\n",
    "Zone de la mémoire où sont stockées les données qui ont la même durée\n",
    "de vie que le programme (variables globales).\n",
    "- __La mémoire automatique__\n",
    "Zone de la mémoire appelée __pile d'exécution__ où sont stockés les blocs d'activation, paramètres et variables locales des sous-programmes. Cette mémoire est gérée automatiquement par le compilateur (réservation et libération). La mémoire est contigüe (sans trous).\n",
    "- __La mémoire dynamique__\n",
    "Zone de la mémoire aussi appelée __tas__ dans laquelle le programmeur peut explicitement réserver (allouer) de la place. Il devra la libérer explicitement. Cette zone est fragmentée (trous)."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "#### Utilisation de la mémoire dynamique\n",
    "\n",
    "L'enregistrement d'une donnée dans une zone de la mémoire dynamique nécessite une __demande d'allocation explicite__ de ladite zone. Cette zone mémoire est référencée à traver  __un pointeur__. Ainsi, l'écriture et la lecture de la donnée se fait exclusivement par ce pointeur.\n",
    "\n",
    "Quand la zone mémoire n'est plus utile, il faut __demander explicitement la libération__ de l'espace mémoire en C. Attention, quand on réalise cette opération, il faut s'assurer qu'aucun pointeur ne référence plus cette zone mémoire un fois désallouée. "
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "\n",
    "### 4.2 Allocation de mémoire\n",
    "\n",
    "La bibliothèque `stdlib.h` (ou `malloc.h`) offre 3 procédures d'allocation de mémoire : `malloc`, `calloc` et `realloc`. Elle définit aussi une procédure de libération de mémoire `free`.\n",
    "\n",
    "#### L'allocateur `malloc`\n",
    "C'est l'allocateur utilisé le plus couramment :\n",
    "> `void* malloc(size_t taille);`\n",
    "\n",
    "Ici on trouve : \n",
    "- Le type de retour `void *` qui représente un type pointeur générique sur une zone mémoire. Le pointeur retourné vaut `NULL` si l'allocation échoue (manque d'espace mémoire contigüe).\n",
    "- Le type `size_t` qui est un alias de `unsigned int` et représente la __taille en octets__ de la zone mémoire réservée.\n",
    "\n",
    "#### L'opérateur `sizeof`\n",
    "- Pour obtenir la taille en octets d'une variable ou d'un type, on utilise la fonction `sizeof()` : \n",
    "> `sizeof(ma_variable)` ou `sizeof(type)`"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "##### Exemples d'allocations : \n",
    "```\n",
    "    char* un_char = malloc(sizeof(char));\n",
    "    char* autre_char = malloc(sizeof(*autre_char)); //taille du type pointé\n",
    "    \n",
    "    enum genre = {H, F, NC};\n",
    "    enum genre * il = malloc(sizeof(enum genre));\n",
    "```\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "#### L'allocateur `calloc`\n",
    "C'est une variante de malloc : \n",
    "> `void* calloc(size_t nombre, size_t taille_element);`\n",
    "\n",
    "Ici, la taille de la zone mémoire allouée est décrite avec deux paramètres :\n",
    "- La taille d'un élément avec `taille_element`\n",
    "- Et le nombre d'éléments de cette taille avec `nombre`.\n",
    "Ainsi, on alloue `nombre * taille_element` octets. \n",
    "\n",
    "> __Note :__ À la différence de malloc, tous les bits de la zone allouée sont positionnés à zéro."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "#### Libérer la mémoire avec  `free` : \n",
    "Désallouer se fait avec la fonction : \n",
    "> `void free(void* pointeur);`\n",
    "\n",
    "L'unique paramètre est le pointeur qui désigne l'adresse de la mémoire à désallouer. \n",
    "> __Attention__ la libération ne modifie pas l'adresse enregistrée dans le pointeur. Il faut explicitement oublier l'adresse non-valide en initialisant le pointeur à `NULL` :\n",
    "\n",
    "```C\n",
    "    free(ptr_int);\n",
    "    ptr_int = NULL;\n",
    "```"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Voici un exemple d'allocation, utilisation et libération de la mémoire (cf. fichier __`Exemple4_2.c`__) :"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "#include <stdio.h>\n",
    "#include <stdlib.h>\n",
    "#include <assert.h>\n",
    "\n",
    "void exemple_dynamique(){\n",
    "    //Allouer dynamiquement un entier\n",
    "    unsigned int taille = sizeof(int);\n",
    "    int *mon_entier = malloc(taille);\n",
    "    //Vérifier le succès de la demande d'allocation\n",
    "    assert(mon_entier != NULL);\n",
    "    \n",
    "    //Initialiser la donnée à travers le pointeur mon_entier\n",
    "    *mon_entier = 10;\n",
    "    //Accéder à la donnée\n",
    "    printf(\"Donnée enregistrée : %d\\n\", *mon_entier);\n",
    "    \n",
    "    //Libérer la mémoire dynamique\n",
    "    free(mon_entier);\n",
    "    //Oublier l'adresse mémoire\n",
    "    mon_entier = NULL;\n",
    "}\n",
    "\n",
    "int main() {\n",
    "    exemple_dynamique();\n",
    "    return EXIT_SUCCESS;\n",
    "}"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "On observe les éléments suivants : \n",
    "\n",
    "- L'allocation est ici réalisée avec la fonction `malloc(taille)` qui retourne un pointeur. Elle demande l'allocation de `taille` octets. \n",
    "Si l'allocation est réalisée avec succès, elle retourne l'adresse de la zone mémoire via le pointeur. Sinon, elle retourne `NULL`.\n",
    "\n",
    "- L'accès à la donnée est réalisé via le pointeur `mon_entier`\n",
    "\n",
    "- La libération de la mémoire utilise la fonction `free(mon_entier)`. \n",
    "\n",
    "> __Attention__ la libération ne modifie pas l'adresse enregistrée dans le pointeur. Il faut explicitement oublier l'adresse non-valide en initialisant le pointeur à `NULL`."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### 4.3 Allocation d'un tableau avec `malloc`\n",
    "Pour allouer un tableau de N éléments dynamiquement, il suffit de demander l'espace mémoire pour contenir les N éléments :  \n",
    "\n",
    "```\n",
    "    // Allocation d'un tableau de 10 entiers\n",
    "    int* mon_tableau = malloc(10*sizeof(int));\n",
    "```\n",
    "On peut alors utiliser la notation `mon_tableau[..]` pour accéder aux éléments du tableau. En effet, les 10 entiers sont enregistrés dans une portion de mémoire dynamique contigüe. `mon_tableau` est un pointeur qui comporte l'adresse de la première case du tableau, et l'accès à la 3ème case se fait par simple décalage d'indice avec l'opérateur `[]`. \n",
    "\n",
    "```\n",
    "    mon_tableau[2] = 20;\n",
    "```\n",
    "> __Attention__ : `sizeof(mon_tableau)` retourne uniquement la taille du pointeur `mon_tableau` alloué dynamiquement ! \n",
    "> Par contre, si un tableau est alloué statiquement, `sizeof` retourne la taille totale du tableau."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "##### Exemple \n",
    "Voici un exemple d'allocation de tableaux dynamiques et statiques, et de la valeur retournée par `sizeof`. Vous pouvez manipuler le fichier __`Exemple4_3.c`__."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "scrolled": true
   },
   "outputs": [],
   "source": [
    "#include <assert.h>\n",
    "#include <stdlib.h>\n",
    "#include <stdio.h>\n",
    "\n",
    "int main(){\n",
    "    int taille_entier = sizeof(int);\n",
    "    printf(\"Taille d'un entier : %d\\n\", taille_entier);\n",
    "    int taille_pointeur = sizeof(int*);\n",
    "    printf(\"Taille d'un pointeur : %d\\n\", taille_pointeur);\n",
    "    \n",
    "    // Allouer un tableau de 10 entiers\n",
    "    int* mon_tableau = malloc(10*taille_entier);\n",
    "    int taille_dynamique = sizeof(mon_tableau);\n",
    "    assert(taille_dynamique == taille_pointeur);\n",
    "    \n",
    "    // Declarer un tableau statique de 10 entiers \n",
    "    int mon_tab[10];\n",
    "    int taille_statique = sizeof(mon_tab);\n",
    "    assert(taille_statique == 10*taille_entier);\n",
    "    \n",
    "    printf(\"%s\", \"Bravo ! Tous les tests passent.\\n\");\n",
    "    return EXIT_SUCCESS;\n",
    "}"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "#### Conséquence sur la définition d'un type tableau dynamique\n",
    "Il n'est pas possible d'utiliser `sizeof` pour connaitre la taille d'un tableau dynamique.\n",
    "\n",
    "> __Bonne pratique :__ Il convient donc d'enregistrer dans une variable la capacité actuelle du tableau à l'aide d'une enregistrement \n",
    "```\n",
    "    struct tab {\n",
    "        int* tableau; //Le tableau, alloué dynamiquement à l'initialisation\n",
    "        int capacite; //La capacité\n",
    "    };\n",
    "    typedef struct tab tab;\n",
    "```"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "---\n",
    "---\n",
    "---"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Exercice 1a : Manipuler les allocateurs\n",
    "Cet exercice a pour but de vous faire manipuler l'allocateur `malloc` et de libérer la mémoire avec `free`. Vous pouvez compléter le fichier __`Exercice1a.c`__ si besoin."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "scrolled": true
   },
   "outputs": [],
   "source": [
    "#include <assert.h>\n",
    "#include <stdlib.h>\n",
    "#include <stdio.h>\n",
    "\n",
    "// Consignes pour une obtenir une exécution sans erreur : \n",
    "//     - compléter les instruction **** TODO **** \n",
    "// Attention : toutes les variables sont ici allouées et libérées dynamiquent\n",
    "\n",
    "int main(){\n",
    "\n",
    "    int* ptr_int; //un entier en mémoire dynamique \n",
    "    // **** TODO ****\n",
    "    // Allocation et initialisation à la valeur 100;\n",
    "\n",
    "\n",
    "    assert(*ptr_int == 100);\n",
    "\n",
    "        \n",
    "    //**** TODO **** \n",
    "    //Libérer toute la mémoire dynamique\n",
    "    \n",
    "    assert(!ptr_int);\n",
    "\n",
    "    printf(\"%s\", \"Bravo ! Tous les tests passent.\\n\");\n",
    "    return EXIT_SUCCESS;\n",
    "}"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Exercice 1b : Manipuler les allocateurs\n",
    "Cet exercice a pour but de vous faire manipuler l'allocateur `calloc` et de libérer la mémoire avec `free`. Vous pouvez compléter le fichier __`Exercice1b.c`__ si besoin."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "scrolled": true
   },
   "outputs": [],
   "source": [
    "#include <assert.h>\n",
    "#include <stdlib.h>\n",
    "#include <stdio.h>\n",
    "\n",
    "// Consignes pour une obtenir une exécution sans erreur : \n",
    "//     - compléter les instruction **** TODO **** \n",
    "// Attention : toutes les variables sont ici allouées et libérées dynamiquent\n",
    "\n",
    "int main(){\n",
    "\n",
    "\n",
    "    float* ptr_float; //un réel en mémoire dynamique \n",
    "    // **** TODO ****\n",
    "    // Allocation du réel avec CALLOC;\n",
    "\n",
    "    assert(*ptr_float == 0.0);\n",
    "\n",
    "    //**** TODO **** \n",
    "    //Libérer toute la mémoire dynamique\n",
    "    assert(!ptr_float);\n",
    "        \n",
    "    printf(\"%s\", \"Bravo ! Tous les tests passent.\\n\");\n",
    "    return EXIT_SUCCESS;\n",
    "}"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Exercice 1c : Manipuler les allocateurs\n",
    "Cet exercice a pour but de vous faire manipuler l'allocateur `calloc` et de libérer la mémoire avec `free`. Vous pouvez compléter le fichier __`Exercice1c.c`__ si besoin."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "scrolled": true
   },
   "outputs": [],
   "source": [
    "#define XXX 1\n",
    "\n",
    "#include <assert.h>\n",
    "#include <stdlib.h>\n",
    "#include <stdio.h>\n",
    "\n",
    "// Consignes pour une obtenir une exécution sans erreur : \n",
    "//     - Remplacer XXX par le bon résultat dans la suite.\n",
    "// Attention : toutes les variables sont ici allouées et libérées dynamiquent\n",
    "\n",
    "int main(){\n",
    "\n",
    "    enum chat {SIAMOIS, CALICO, PERSAN, TABBY};\n",
    "    enum chat * my_cat;\n",
    "    my_cat = calloc(1, sizeof(enum chat));\n",
    "    assert(*my_cat == XXX);\n",
    "\n",
    "    //**** TODO **** \n",
    "    //Libérer toute la mémoire dynamique\n",
    "    \n",
    "    assert(!my_cat);\n",
    "\n",
    "    printf(\"%s\", \"Bravo ! Tous les tests passent.\\n\");\n",
    "    return EXIT_SUCCESS;\n",
    "}"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Exercice 1.d : Manipuler les allocateurs\n",
    "Cet exercice a pour but de vous faire allouer de la mémoire pour enregistrer un tableau de caractères. Vous pouvez completer le fichier __`Exercice1d.c`__ si besoin.\n",
    "\n",
    "Pour rappel, en C, une chaine de caratères est un tableau de caractères qui termine par le caractère `\\0`. Cet exercice utilise la bibliothèque [`string.h`](https://fr.wikipedia.org/wiki/String.h) qui offre des sous-programmes permettant de manipuler des chaines de caractère.\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "scrolled": true
   },
   "outputs": [],
   "source": [
    "#include <assert.h>\n",
    "#include <stdlib.h>\n",
    "#include <stdio.h>\n",
    "#include <string.h>\n",
    "\n",
    "// Consignes pour une obtenir une exécution sans erreur : \n",
    "//     - compléter les instruction **** TODO ****\n",
    "// Attention : toutes les variables sont ici allouées et libérées dynamiquent\n",
    "\n",
    "int main(){\n",
    "    char* chaine; //une chaine de caractère dynamique\n",
    "    // **** TODO ****\n",
    "    // Allocation pour pouvoir y copier la chaine constante \"LANGAGE_C\"\n",
    "    // à l'aide de la procédure strcpy() de string.h\n",
    "\n",
    "    strcpy(chaine, \"LANGAGE_C\");\n",
    "    assert(strcmp(chaine, \"LANGAGE_C\")==0);\n",
    "    assert(chaine[0] == 'L');\n",
    "    assert(chaine[9] == '\\0');\n",
    "    \n",
    "    //**** TODO **** \n",
    "    //Libérer toute la mémoire dynamique\n",
    "    \n",
    "    assert(!chaine);\n",
    "        \n",
    "    printf(\"%s\", \"Bravo ! Tous les tests passent.\\n\");\n",
    "    return EXIT_SUCCESS;\n",
    "}"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "---\n",
    "---\n",
    "---"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Exercice 2 : Allocation dynamique et statique d'un tableau.\n",
    "Dans l'exercice suivant, il faut compléter des sous-programmes permettant d'initialiser et manipuler les structures de données nécessaires à la réalisation d'une version simplifiée du jeu de UNO. \n",
    "\n",
    "Dans ce jeu, il y a 10 cartes de 4 couleurs différentes (jaune, rouge, vert et bleu), numérotées entre 0 et 9. Une main de 7 cartes est distribuée à 2 joueurs. Le premier joueur à avoir posé toutes ses cartes est le vainqueur. Une carte ne peut être jouée que si elle présente le même numéro OU la même couleur que la précédente. Si un joueur ne peut poser une carte, il doit piocher une carte dans le tas de cartes restantes. \n",
    "\n",
    "Cet exercice a pour but de vous faire pratiquer la manipulation des tableaux dynamiques et statiques. Les consignes précises sont décrites dans le fichier ci-après. Vous pouvez completer le fichier __`Exercice2.c`__ si besoin.\n",
    "\n",
    "L'objectif de l'exercice est de réaliser une exécution sans erreur du programme de test proposé (`test_preparer_jeu_UNO`). Ce programme de test permet de vérifier la bonne préparation du jeu, et donc des étapes suivantes : \n",
    "- la création du jeu de 4*10 cartes, \n",
    "- la création de la main des deux joueurs. Chaque main comporte 7 cartes.\n",
    "- la création de la derniere carte posée pour démarrer le jeu."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "scrolled": true
   },
   "outputs": [],
   "source": [
    "#define XXX 1\n",
    "\n",
    "// Consignes : \n",
    "//  1. Remplacer XXX par le bon résultat dans la suite.\n",
    "//  2. Compléter avec les instructions nécessaires en lieu et place de \n",
    "//     **** TODO ****\n",
    "\n",
    "#include <assert.h>\n",
    "#include <stdlib.h>\n",
    "#include <stdio.h>\n",
    "#include <stdbool.h>\n",
    "#include <time.h>\n",
    "\n",
    "#define NB_VALEURS XXX\n",
    "#define NB_CARTES 4*NB_VALEURS\n",
    "\n",
    "//Définition du type enseigne\n",
    "enum couleur {JAUNE, ROUGE, VERT, BLEU};\n",
    "typedef enum couleur couleur;\n",
    "\n",
    "//Tableau de caractères représentant les couleurs\n",
    "char C[4] = {'J', 'R', 'V', 'B'};\n",
    "\n",
    "//Définition du type carte\n",
    "struct carte {\n",
    "    couleur couleur;\n",
    "    int valeur; //valeur >= 0 && valeur < NB_VALEURS\n",
    "    bool presente; // la carte est-elle presente dans le jeu ?\n",
    "};\n",
    "typedef struct carte carte;\n",
    "\n",
    "//Définition du type jeu complet pour enregistrer NB_CARTES cartes.\n",
    "typedef carte jeu[NB_CARTES];\n",
    "\n",
    "//Définition du type t_main, capable d'enregistrer un nombre variable de cartes.\n",
    "struct main {\n",
    "    carte * main; //tableau des cartes dans la main. \n",
    "    int nb; //monbre de cartes\n",
    "};\n",
    "typedef struct main t_main;\n",
    "\n",
    "\n",
    "/**\n",
    " * \\brief Initialiser une carte avec une couleur et une valeur. \n",
    " * \\param[in] c couleur de la carte\n",
    " * \\param[in] v valeur de la carte\n",
    " * \\param[in] ej booléen presente\n",
    " * \\param[out] la_carte \n",
    " */\n",
    "void init_carte(carte* la_carte, couleur c, int v, bool pr){\n",
    "    la_carte->couleur = c;\n",
    "    la_carte->valeur = v;\n",
    "    la_carte->presente = pr;\n",
    "}\n",
    "\n",
    "/**\n",
    " * \\brief Vérifie si la valeur de la carte est conforme à l'invariant.\n",
    " * \\param[in] c la carte\n",
    " * \\return bool vrai si la valeur est conforme, faux sinon.\n",
    " */\n",
    " bool est_conforme(carte c){\n",
    "    return (c.valeur>=0 && c.valeur<NB_VALEURS);\n",
    "}\n",
    "\n",
    "/**\n",
    " * \\brief Initialiser une main.\n",
    " * \\param[in] N nombre de cartes composant la main.  Précondition : N <= (NB_CARTES - 1) div 2\n",
    " * \\param[out] la_main créée\n",
    " * \\return true si l'initialisation a échouée.\n",
    " */\n",
    "bool init_main(t_main* la_main, int N){\n",
    "    assert(N <= (NB_CARTES-1)/2);\n",
    "    // ***** TODO ***** \n",
    "    // Corriger l'initialisation du tableau main\n",
    "    la_main->main = NULL;\n",
    "    la_main->nb = N;\n",
    "    return (la_main==NULL); //allocation réussie ?\n",
    "}\n",
    "\n",
    "/**\n",
    " * \\brief Initialiser le jeu en ajoutant toutes les cartes possibles au jeu. \n",
    " * \\brief Chaque carte est alors présente dans le jeu.\n",
    " * \\param[out] le_jeu tableau de cartes avec les 4 couleurs et NB_VALEURS valeurs possibles\n",
    " */\n",
    "void init_jeu(jeu le_jeu){\n",
    "    int k=0;\n",
    "    for (int i=0 ; i<4 ; i++){\n",
    "        for (int j=0 ; j<NB_VALEURS ; j++){\n",
    "            init_carte(&(le_jeu[k]), i, j, true);\n",
    "            k++;\n",
    "        }\n",
    "    }\n",
    "}\n",
    "\n",
    "\n",
    "/**\n",
    " * \\brief Copie les valeurs de la carte src dans la carte dest.\n",
    " * \\param[in] src carte à copier\n",
    " * \\param[out] dest carte destination de la copie \n",
    " */\n",
    "void copier_carte(carte* dest, carte src){\n",
    "    dest->couleur = src.couleur;\n",
    "    dest->valeur = src.valeur;\n",
    "    dest->presente = src.presente;\n",
    "}\n",
    "\n",
    "/**\n",
    " * \\brief Afficher une carte.\n",
    " * \\param[in] cte carte à afficher\n",
    " */\n",
    "void afficher_carte(carte cte){\n",
    "    printf(\"(%c;%d;%d)\\t\", C[cte.couleur], cte.valeur, cte.presente);\n",
    "}\n",
    "\n",
    "\n",
    "/**\n",
    " * \\brief Afficher le jeu.\n",
    " * \\param[in] le_jeu complet\n",
    " */\n",
    "void afficher_jeu(jeu le_jeu){\n",
    "    // ***** TODO ***** \n",
    "    // Afficher le jeu complet. Les carte sont listées sur une même ligne, \n",
    "    // et séparées par une tabulation \\t\n",
    "    printf(\"\\n\");\n",
    "}\n",
    "\n",
    "/**\n",
    " * \\brief Afficher une main.\n",
    " * \\param[in] la_main la main a afficher\n",
    " */\n",
    "void afficher_main(t_main la_main){\n",
    "    // ***** TODO ***** \n",
    "    // Afficher le jeu complet. Les carte sont listées sur une même ligne, \n",
    "    // et séparées par une tabulation \\t\n",
    "    printf(\"\\n\");\n",
    "}\n",
    "\n",
    "/**\n",
    " * \\brief mélange le jeu.\n",
    " * \\param[in out] le_jeu complet mélangé\n",
    " */\n",
    "void melanger_jeu(jeu le_jeu){\n",
    "    for (int k=0; k<1000; k++){\n",
    "        // Choisir deux cartes aléatoirement\n",
    "        int i = rand()%NB_CARTES;\n",
    "        int j = rand()%NB_CARTES;        \n",
    "        // Les échanger\n",
    "        // ***** TODO **** \n",
    "    }\n",
    "}\n",
    "\n",
    "/**\n",
    " \\brief Distribuer N cartes à chacun des deux joueurs, en alternant les joueurs.\n",
    " * \\param[in out] le_jeu complet.\n",
    " *       Si la carte c est distribuée dans une main, c.presente devient faux.\n",
    " * \\param[in] N nombre de cartes distribuées à chaque joueur.  Précondition : N <= (NB_CARTES - 1) div 2\n",
    " * \\param[out] m1 main du joueur 1.\n",
    " * \\param[out] m2 main du joueur 2.\n",
    " */\n",
    "void distribuer_mains(jeu le_jeu, int N, t_main* m1, t_main* m2){\n",
    "    assert(N <= (NB_CARTES-1)/2);\n",
    "\n",
    "    //Initialiser les mains de N cartes\n",
    "    bool errA = init_main(m1, N);\n",
    "    bool errB = init_main(m2, N);\n",
    "    assert(!errA && !errB);\n",
    "    \n",
    "    //Distribuer les cartes\n",
    "    for (int i=0; i<N; i++){\n",
    "        // ajout d'une carte dans la main m1\n",
    "        copier_carte(&(m1->main[i]), le_jeu[2*i]);\n",
    "        // ajout d'une carte dans la main m2\n",
    "        copier_carte(&(m2->main[i]), le_jeu[2*i+1]);\n",
    "        //mise à jour de presente à false dans le_jeu\n",
    "        le_jeu[2*i].presente = false;\n",
    "        le_jeu[2*i+1].presente = false;\n",
    "    }\n",
    "}\n",
    "\n",
    "/**\n",
    " * \\brief Initialise le jeu de carte, les mains des joueurs et la carte 'last'.\n",
    " * \\param[out] le_jeu complet avec les 4 couleurs et 10 valeurs possibles.\n",
    " *                Ce jeu est mélangé.\n",
    " *                Si la carte est inclue dans une main ou est la derniere carte jouée,\n",
    " *                Alors carte.presente vaut faux.\n",
    " * \\param[in] N nombre de cartes par main.  Precondition : N <= (NB_CARTES-1)/2);\n",
    " * \\param[out] main_A main du joueur A.\n",
    " * \\param[out] main_B main du joueur B.\n",
    " * \\param[out] last la derniere carte jouée par un des joueurs.\n",
    " */\n",
    "int preparer_jeu_UNO(jeu le_jeu, int N, t_main* main_A, t_main* main_B, carte* last){\n",
    "    assert(N <= (NB_CARTES-1)/2);\n",
    "    \n",
    "    //Initialiser le générateur de nombres aléatoires\n",
    "    time_t t;\n",
    "    srand((unsigned) time(&t));\n",
    " \n",
    "    //Initialiser le jeu\n",
    "    init_jeu(le_jeu);\n",
    "    \n",
    "    //Melanger le jeu\n",
    "    melanger_jeu(le_jeu);\n",
    "\n",
    "    //Distribuer N cartes à chaque joueur\n",
    "    distribuer_mains(le_jeu, N, main_A, main_B);\n",
    "\n",
    "    //Initialiser last avec la (2N+1)-ème carte du jeu.\n",
    "    copier_carte(last, le_jeu[2*N]);\n",
    "    le_jeu[2*N].presente = false; //carte n'est plus presente dans le_jeu\n",
    "    \n",
    "    return EXIT_SUCCESS;\n",
    "}\n",
    "\n",
    "void test_preparer_jeu_UNO(){\n",
    "    //Déclarer un jeu (tableau statique), les deux mains (tableaux dynamiques) et \n",
    "    //la carte last.\n",
    "    jeu le_jeu;\n",
    "    t_main main_A, main_B;\n",
    "    carte last;\n",
    " \n",
    "    //Préparer le jeu, les deux mains de 7 cartes et la carte last\n",
    "    int retour = preparer_jeu_UNO(le_jeu, 7, &main_A, &main_B, &last);\n",
    "    printf(\"\\n Le jeu mélangé avec les cartes presentes (c ; v ; p) : \\n\");\n",
    "    afficher_jeu(le_jeu);\n",
    "    printf(\"\\n Les deux mains : \\n\");\n",
    "    afficher_main(main_A);\n",
    "    afficher_main(main_B);\n",
    "    printf(\"\\n La carte last : \");\n",
    "    afficher_carte(last);\n",
    "    printf(\"\\n\");\n",
    "\n",
    "    //Vérifier le jeu et les mains.\n",
    "    assert(retour == EXIT_SUCCESS);\n",
    "    assert(main_A.nb == 7 && main_B.nb == 7);\n",
    "    assert(main_A.main != NULL && main_B.main != NULL);    \n",
    "    assert(est_conforme(main_A.main[0]));\n",
    "    assert(est_conforme(main_B.main[0]));\n",
    "    assert(est_conforme(last));\n",
    "        \n",
    "    //Détruire la mémoire allouée dynamiquement\n",
    "    // ***** TODO *****\n",
    "    \n",
    "    assert(main_A.main == NULL);\n",
    "    assert(main_B.main == NULL);\n",
    " \n",
    "}\n",
    "\n",
    "int main(void) {\n",
    "  \n",
    "    test_preparer_jeu_UNO();\n",
    "    \n",
    "    printf(\"%s\", \"\\n Bravo ! Tous les tests passent.\\n\");\n",
    "    return EXIT_SUCCESS;\n",
    "}\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "---\n",
    "---\n",
    "---"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### 4.4 La réallocation avec `Realloc`\n",
    "En C, il est possible de réallouer une variable dynamique avec la procédure : \n",
    "> `void* realloc(void* ptr_mem, size_t taille)`\n",
    "\n",
    "Elle prend en paramètres : \n",
    "- le pointeur `ptr_mem` sur la zone mémoire dont on veut modifier la taille, \n",
    "- la nouvelle `taille` de la zone mémoire. \n",
    "\n",
    "Elle retourne : \n",
    "- un pointeur sur la zone mémoire allouée. __Si cette réallocation échoue, elle retoune `NULL`__. \n",
    "\n",
    "> __Note :__ La réallocation copie également les données enregistrées dans la zone mémoire initiale vers la nouvelle zone mémoire. \n",
    "\n",
    "On peut se servir de `realloc` pour : \n",
    "- Augmenter la taille mémoire allouée à l'origine.\n",
    "- Réduire la taille mémoire allouée à l'origine.\n",
    "- Libérer la mémoire. Dans ce cas, le paramètre `taille` vaut 0. Ce comportement est équivalement à `free`.\n",
    "- Allouer une nouvelle zone mémoire. Dans ce cas, le paramètre `ptr_mem` vaut `NULL`. Ce comportement est équivalent à `malloc`.\n",
    "\n",
    "Voici quelques exemples d'utilisation."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Exemple d'une _mauvaise_ utilisation de `realloc`\n",
    "Vous pouvez manipuler le fichier __`Exemple4_4_mauvaise.c`__ si besoin."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "#include <assert.h>\n",
    "#include <stdlib.h>\n",
    "#include <stdio.h>\n",
    "\n",
    "#define TAILLE 10\n",
    "\n",
    "int main(){\n",
    "\n",
    "    // Allouer un tableau de TAILLE entiers\n",
    "    int* tableau = malloc(TAILLE*sizeof(int));\n",
    "    assert(tableau); //allocation réussie ?\n",
    "    \n",
    "    // Initialiser les éléments à 1\n",
    "    for (int i=0; i<TAILLE; i++){\n",
    "        tableau[i]=1;\n",
    "    }\n",
    "    \n",
    "    // Augmenter la taille du tableau pour enregistrer TAILLE entiers supplémentaires.\n",
    "    tableau = realloc(tableau, (TAILLE+TAILLE)*sizeof(int));\n",
    "    assert(tableau); // ré-allocation réussie ?\n",
    "    \n",
    "    //test des 5 premiers éléments\n",
    "    assert(tableau[0]==1 && tableau[1]==1 && tableau[2]==1 && tableau[3]==1 && tableau[4]==1); \n",
    "\n",
    "    for (int i=TAILLE; i<TAILLE+TAILLE; i++){\n",
    "        tableau[i]=2;\n",
    "    }\n",
    "    \n",
    "    //test de 5 nouveaux éléments\n",
    "    assert(tableau[TAILLE]==2 && tableau[TAILLE+1]==2 && tableau[TAILLE+2]==2 && tableau[TAILLE+3]==2 && tableau[TAILLE+4]==2); \n",
    "    \n",
    "    printf(\"%s\", \"\\n Bravo ! Tous les tests passent.\\n\");\n",
    "    return EXIT_SUCCESS;\n",
    "}"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "__Observation :__\n",
    "Ici, l'allocation et la réallocation se sont déroulées avec succès et les données présentes avant la réallocation sont toujours présentes après l'allocation. De plus, l'utilisation de l'espace supplémentaire se fait normalement. \n",
    "\n",
    "Dans l'exemple suivant, on vous propose d'augmenter la constante pré-processeur `INC` pour observer l'échec de la demande de réallocation. Vous pouvez manipuler le fichier __`Exemple4_4_mauvaise_bis.c`__ si besoin."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "#include <assert.h>\n",
    "#include <stdlib.h>\n",
    "#include <stdio.h>\n",
    "\n",
    "#define TAILLE 1000000\n",
    "#define INC 1e10\n",
    "\n",
    "int main(){\n",
    "\n",
    "    // Allouer un tableau de TAILLE entiers.\n",
    "    int* tableau = malloc(TAILLE*sizeof(int));\n",
    "    assert(tableau); //allocation réussie ?\n",
    "    \n",
    "    // Initialiser les éléments à 1\n",
    "    for (int i=0; i<TAILLE; i++){\n",
    "        tableau[i]=1;\n",
    "    }\n",
    "    \n",
    "    // Augmenter la taille du tableau pour enregistrer INC entiers supplémentaires.\n",
    "    tableau = realloc(tableau, (TAILLE+INC)*sizeof(int));\n",
    "    assert(tableau);\n",
    "    \n",
    "    // Initialiser l'élément d'indice 0 à 2\n",
    "    tableau[0]=2;\n",
    "    \n",
    "    printf(\"%s\", \"\\n Bravo ! Tous les tests passent.\\n\");\n",
    "    return EXIT_SUCCESS;\n",
    "}"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "__Observations :__\n",
    "\n",
    "N.B. : Pour lire les obsevations, il faut afficher les numéros de ligne du programme. Pour cela, il faut se rendre dans le menu 'Affichage' et sélectionner l'option 'Afficher/Masquer les numéros de ligne'.\n",
    "\n",
    "Voici les principales observations : \n",
    "\n",
    "- L'assertion de la ligne 21 n'est pas vérifiée quand `INC` devient trop grand : le pointeur tableau est donc `NULL`. \n",
    "\n",
    "- Si on commente l'instruction de la ligne 21, et que l'on ré-exécute le programme, on obtient une erreur `Executable exited with code -11`, ce qui correspond à un accès à une adresse mémoire non valide (i.e. un segmentation fault). L'adresse non valide est l'adresse `NULL` car à la ligne 24, on accède au premier élément du tableau. Le premier élément n'est plus disponible ici car la réallocation a échoué, et le pointeur tableau a été mis à `NULL` à la ligne 20 par `realloc`. \n",
    "\n",
    "__*******  Ici, on a perdu l'accès aux données présentes dans le tableau d'origine avant réallocation *******__\n",
    "\n",
    "> On observe ici __une double peine__ : \n",
    "> - La réallocation a échoué, \n",
    "> - Les données présentes dans le tableau avant l'appel à `realloc` sont définitivement perdues. \n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Exemple d'une _bonne_  utilisation de `realloc`.\n",
    "Vous pouvez manipuler le fichier __`Exemple4_4_bonne.c`__ si besoin."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "#include <assert.h>\n",
    "#include <stdlib.h>\n",
    "#include <stdio.h>\n",
    "\n",
    "#define TAILLE 1e6\n",
    "#define INC 1e14\n",
    "\n",
    "int main(){\n",
    "\n",
    "    // Allouer un tableau de TAILLE entiers initialisés à 1.\n",
    "    int* tableau = malloc(TAILLE*sizeof(int));\n",
    "    assert(tableau); //allocation réussie ?\n",
    "    \n",
    "    // Initialisation à 1\n",
    "    for (int i=0; i<TAILLE; i++){\n",
    "        tableau[i]=1;\n",
    "    }\n",
    "    \n",
    "    // Augmentater la taille du tableau pour enregistrer 10 entiers.\n",
    "    int* nouveau = realloc(tableau, (TAILLE+INC)*sizeof(int));\n",
    "    if (nouveau) {\n",
    "        //recopie de l'adresse uniquement si succès \n",
    "        tableau = nouveau;\n",
    "    }\n",
    "    assert(tableau[0]==1);\n",
    "    \n",
    "    printf(\"%s\", \"\\n Bravo ! Tous les tests passent.\\n\");\n",
    "    return EXIT_SUCCESS;\n",
    "}"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "__Observations :__\n",
    "\n",
    "Un appel convenable à `realloc` est illustré à la ligne 20 : ici, l'éventuel échec d'allocation mettra le pointeur `nouveau` à `NULL`, et non le pointeur `tableau`. Si et seulement si `nouveau` n'est pas `NULL`, on recopie la nouvelle adresse dans le pointeur `tableau`. On évite ainsi la double peine."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "---\n",
    "---\n",
    "---"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Exercice 3 : Ré-allocation et jeu de Uno.\n",
    "Toujour dans le jeu de Uno, on cherche à tester la procédure qui permet de piocher une carte parmi les cartes qui ne sont pas en jeu. \n",
    "Une carte est en jeu si elle appartient à une des deux mains, ou si elle est la dernière jouée.\n",
    "\n",
    "Dans le tableau statique `le_jeu` qui contient toutes les cartes du jeu, on référence une carte comme 'présente' si elle n'est pas en jeu. Quand on pioche, on cherche la première carte présente dans `le_jeu` et on l'ajoute à la main courante. La carte piochée du tableau `le_jeu` y est indiquée comme non-présente.\n",
    "\n",
    "L'objet de cet exercice est d'exécuter les tests de la procédure `carte * piocher(jeu le_jeu, t_main* main)` qui : \n",
    "- retourne un pointeur sur la carte piochée dans le jeu \n",
    "- null si elle aucune carte ne peut être piochée ou si la réallocation de mémoire échoue.\n",
    "\n",
    "L'essentiel du travail est à réaliser au niveau de cette procédure `piocher`. Vous pouvez manipuler le fichier __`Exercice3.c`__ si besoin."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "\n",
    "// Consignes : \n",
    "//  1. Compléter avec les instructions requises en lieu et place de *** TODO ***\n",
    "\n",
    "#include <assert.h>\n",
    "#include <stdlib.h>\n",
    "#include <stdio.h>\n",
    "#include <stdbool.h>\n",
    "#include <time.h>\n",
    "\n",
    "#define NB_VALEURS 10\n",
    "#define NB_CARTES 4*NB_VALEURS\n",
    "\n",
    "//Définition du type enseigne\n",
    "enum couleur {JAUNE, ROUGE, VERT, BLEU};\n",
    "typedef enum couleur couleur;\n",
    "\n",
    "//Tableau de caractères représentant les couleurs\n",
    "char C[4] = {'J', 'R', 'V', 'B'};\n",
    "\n",
    "//Définition du type carte\n",
    "struct carte {\n",
    "    couleur couleur;\n",
    "    int valeur; // Invariant : valeur >= 0 && valeur < NB_VALEURS\n",
    "    bool presente; // la carte est-elle presente dans le jeu ?\n",
    "};\n",
    "typedef struct carte carte;\n",
    "\n",
    "//Définition du type jeu complet pour enregistrer NB_CARTES cartes.\n",
    "typedef carte jeu[NB_CARTES];\n",
    "\n",
    "//Définition du type t_main, capable d'enregistrer un nombre variable de cartes.\n",
    "struct main {\n",
    "    carte * main; //tableau des cartes dans la main. \n",
    "    int nb; //monbre de cartes\n",
    "};\n",
    "typedef struct main t_main;\n",
    "\n",
    "\n",
    "/**\n",
    " * \\brief Initialiser une carte avec une couleur et une valeur. \n",
    " * \\param[in] c couleur de la carte\n",
    " * \\param[in] v valeur de la carte\n",
    " * \\param[in] ej booléen presente\n",
    " * \\param[out] la_carte \n",
    " */\n",
    "void init_carte(carte* la_carte, couleur c, int v, bool pr){\n",
    "    la_carte->couleur = c;\n",
    "    la_carte->valeur = v;\n",
    "    la_carte->presente = pr;\n",
    "}\n",
    "\n",
    "/**\n",
    " * \\brief Vérifie si la valeur de la carte est conforme à l'invariant.\n",
    " * \\param[in] c la carte\n",
    " * \\return bool vrai si la valeur est conforme, faux sinon.\n",
    " */\n",
    " bool est_conforme(carte c){\n",
    "    return (c.valeur>=0 && c.valeur<NB_VALEURS);\n",
    "}\n",
    "\n",
    "/**\n",
    " * \\brief Copie les valeurs de la carte src dans la carte dest.\n",
    " * \\param[in] src carte à copier\n",
    " * \\param[out] dest carte destination de la copie \n",
    " */\n",
    "void copier_carte(carte* dest, carte src){\n",
    "    dest->couleur = src.couleur;\n",
    "    dest->valeur = src.valeur;\n",
    "    dest->presente = src.presente;\n",
    "}\n",
    "\n",
    "\n",
    "/**\n",
    " * \\brief Afficher une carte.\n",
    " * \\param[in] cte carte à afficher\n",
    " */\n",
    "void afficher_carte(carte cte){\n",
    "    printf(\"(%c;%d;%d)\\t\", C[cte.couleur],cte.valeur, cte.presente);\n",
    "}\n",
    "\n",
    "/**\n",
    " * \\brief Initialiser une main.\n",
    " * \\param[in] N nombre de cartes composant la main.  Précondition : N <= (NB_CARTES - 1) div 2\n",
    " * \\param[out] la_main créée\n",
    " * \\return true si l'initialisation a échouée.\n",
    " */\n",
    "bool init_main(t_main* la_main, int N){\n",
    "    assert(N <= (NB_CARTES-1)/2);\n",
    "    la_main->main = malloc(N*sizeof(carte));\n",
    "    la_main->nb = N;\n",
    "    return (la_main==NULL); //allocation réussie ?\n",
    "}\n",
    "\n",
    "/**\n",
    " * \\brief Initialiser le jeu en ajoutant toutes les cartes possibles au jeu.\n",
    " * \\param[out] le_jeu tableau de cartes avec les 4 couleurs et NB_VALEURS valeurs possibles\n",
    " */\n",
    "void init_jeu(jeu le_jeu){\n",
    "    int k=0;\n",
    "    for (int i=0 ; i<4 ; i++){\n",
    "        for (int j=0 ; j<NB_VALEURS ; j++){\n",
    "            init_carte(&(le_jeu[k]), i, j, true);\n",
    "            k++;\n",
    "        }\n",
    "    }\n",
    "}\n",
    "\n",
    "/**\n",
    " * \\brief Afficher le jeu.\n",
    " * \\param[in] le_jeu complet avec les 4 couleurs et 910valeurs possibles\n",
    " */\n",
    "void afficher_jeu(jeu le_jeu){\n",
    "    for (int k=0; k<NB_CARTES; k++){\n",
    "        afficher_carte(le_jeu[k]);\n",
    "    }\n",
    "    printf(\"\\n\");\n",
    "}\n",
    "\n",
    "/**\n",
    " * \\brief Afficher une main.\n",
    " * \\param[in] la_main la main a afficher\n",
    " */\n",
    "void afficher_main(t_main la_main){\n",
    "    for (int k=0; k<la_main.nb; k++){\n",
    "        afficher_carte(la_main.main[k]);\n",
    "    }\n",
    "    printf(\"\\n\");\n",
    "}\n",
    "\n",
    "/**\n",
    " * \\brief mélange le jeu.\n",
    " * \\param[in out] le_jeu complet\n",
    " */\n",
    "void melanger_jeu(jeu le_jeu){\n",
    "    for (int i=0; i<1000; i++){\n",
    "        // Choisir deux cartes aléatoirement\n",
    "        int i = rand()%NB_CARTES;\n",
    "        int j = rand()%NB_CARTES;        \n",
    "        // Les échanger\n",
    "        carte mem;\n",
    "        copier_carte(&mem, le_jeu[i]); \n",
    "        copier_carte(&(le_jeu[i]), le_jeu[j]); \n",
    "        copier_carte(&(le_jeu[j]), mem); \n",
    "    }\n",
    "}\n",
    "\n",
    "\n",
    "/**\n",
    " \\brief Distribuer N cartes à chacun des deux joueurs, en alternant les joueurs.\n",
    " * \\param[in out] le_jeu complet.\n",
    " *       Si la carte c est distribuée dans une main, c.presente devient faux.\n",
    " * \\param[in] N nombre de cartes distribuées à chaque joueur.  Précondition : N <= (NB_CARTES - 1) div 2\n",
    " * \\param[out] m1 main du joueur 1.\n",
    " * \\param[out] m2 main du joueur 2.\n",
    " */\n",
    "void distribuer_mains(jeu le_jeu, int N, t_main* m1, t_main* m2){\n",
    "    assert(N <= (NB_CARTES-1)/2);\n",
    "\n",
    "    //Initialiser les mains de N cartes\n",
    "    bool errA = init_main(m1, N);\n",
    "    bool errB = init_main(m2, N);\n",
    "    assert(!errA && !errB);\n",
    "    \n",
    "    //Distribuer les cartes\n",
    "    for (int i=0; i<N; i++){\n",
    "        // ajout d'une carte dans la main m1\n",
    "        copier_carte(&(m1->main[i]), le_jeu[2*i]);\n",
    "        // ajout d'une carte dans la main m2\n",
    "        copier_carte(&(m2->main[i]), le_jeu[2*i+1]);\n",
    "        //mise à jour de presente à false dans le_jeu\n",
    "        le_jeu[2*i].presente = false;\n",
    "        le_jeu[2*i+1].presente = false;\n",
    "    }\n",
    "}\n",
    "\n",
    "/**\n",
    " * \\brief Vérifie si les cartes c1 et c2 on la même couleur et la même valeur.\n",
    " * \\param[in] c1 carte\n",
    " * \\param[in] c2 carte\n",
    " * \\return bool Vrai si les deux cartes ont même valeur et couleur.\n",
    "*/\n",
    "bool est_egale(carte c1, carte c2){\n",
    "    return ((c1.couleur == c2.couleur) && (c1.valeur == c2.valeur));\n",
    "}\n",
    "\n",
    "/**\n",
    " * \\brief Vérifie si la carte c est présente dans la main.\n",
    " * \\param[in] main main d'un joueur\n",
    " * \\param[in] c carte\n",
    " * \\return bool Vrai si la carte est presente dans la main, faux sinon.\n",
    "*/\n",
    "bool est_presente_main(t_main main, carte c){\n",
    "    int i = 0;\n",
    "    while (i < main.nb && !est_egale(main.main[i], c)) {\n",
    "        i++;\n",
    "    }\n",
    "    return !(i == main.nb);\n",
    "}\n",
    "\n",
    "\n",
    "/**\n",
    " * \\brief Piocher une carte dans le jeu et l'inclure dans la main en paramètre.\n",
    " * \\param[in out] le_jeu complet avec les 4 couleurs et 10 valeurs possibles.\n",
    " *                Ce jeu est mélangé.\n",
    " *                Si la carte est inclue dans une main ou est la derniere carte jouée,\n",
    " *                Alors carte.presente vaut faux.\n",
    " * \\param[in out] main main d'un joueur\n",
    " * \\return carte * un pointeur sur la carte piochee dans le_jeu en paramètre. \n",
    " * Ce pointeur vaut NULL si aucune carte ne peut être piochée ou si l'allocation de mémoire échoue.\n",
    "*/\n",
    "carte * piocher(jeu le_jeu, t_main* main){\n",
    "    // Recherche une carte presente dans le jeu.\n",
    "    carte *carte_piochee = le_jeu;\n",
    "    int i = 0;\n",
    "    while(i < NB_CARTES && carte_piochee->presente == false){\n",
    "        carte_piochee = carte_piochee + 1;\n",
    "        i++;\n",
    "    }\n",
    "    if (i == NB_CARTES) {\n",
    "        carte_piochee = NULL;\n",
    "    } else {\n",
    "        // Inserer la carte dans la main       \n",
    "        //*** TODO *** ;\n",
    "        // Reallouer la mémoire pour enregistrer une carte de plus dans la main.\n",
    "        // Penser à l'echec de la reallocation\n",
    "        \n",
    "        // Copier la carte_piochee dans la main\n",
    "        \n",
    "        // Indiquer que carte_piochee n'est plus presente dans le_jeu\n",
    "        \n",
    "    }\n",
    "    return carte_piochee;\n",
    "}\n",
    "\n",
    "/**\n",
    " * \\brief Initialise le jeu de carte, les mains des joueurs et la carte 'last'.\n",
    " * \\param[out] le_jeu complet avec les 4 couleurs et 10 valeurs possibles.\n",
    " *                Ce jeu est mélangé.\n",
    " *                Si la carte est inclue dans une main ou est la derniere carte jouée,\n",
    " *                Alors carte.presente vaut faux.\n",
    " * \\param[in] N nombre de cartes par main.  Precondition : N <= (NB_CARTES-1)/2);\n",
    " * \\param[out] main_A main du joueur A.\n",
    " * \\param[out] main_B main du joueur B.\n",
    " * \\param[out] last la derniere carte jouée par un des joueurs.\n",
    " */\n",
    "int preparer_jeu_UNO(jeu le_jeu, int N, t_main* main_A, t_main* main_B, carte* last){\n",
    "    assert(N <= (NB_CARTES-1)/2);\n",
    "\n",
    "    //Initialiser le générateur de nombres aléatoires\n",
    "    time_t t;\n",
    "    srand((unsigned) time(&t));\n",
    " \n",
    "    //Initialiser le jeu\n",
    "    init_jeu(le_jeu);\n",
    "    \n",
    "    //Melanger le jeu\n",
    "    melanger_jeu(le_jeu);\n",
    "\n",
    "    //Distribuer N cartes à chaque joueur\n",
    "    distribuer_mains(le_jeu, N, main_A, main_B);\n",
    "\n",
    "    //Initialiser last avec la (2N+1)-ème carte du jeu.\n",
    "    copier_carte(last, le_jeu[2*N]);\n",
    "    le_jeu[2*N].presente = false; //carte n'est plus presente dans le_jeu\n",
    "\n",
    "    return EXIT_SUCCESS;\n",
    "}\n",
    "\n",
    "void test_piocher(){\n",
    "    jeu le_jeu; // le jeu de cartes\n",
    "    t_main main_A, main_B; // les deux mains\n",
    "    carte last; // la derniere carte posee\n",
    "   \n",
    "    //Préparer le jeu, les deux mains de 7 cartes et la carte last\n",
    "    int retour = preparer_jeu_UNO(le_jeu, 7, &main_A, &main_B, &last);\n",
    "    printf(\"\\n Les deux mains : \\n\");\n",
    "    afficher_main(main_A);\n",
    "    afficher_main(main_B);\n",
    "\n",
    "    int mem_taille = main_A.nb;\n",
    "    \n",
    "    //Le joueur A pioche une carte dans le_jeu\n",
    "    carte *c_piochee = piocher(le_jeu, &main_A);\n",
    "    \n",
    "    // Une carte a-t-elle été piochée ?\n",
    "    assert(c_piochee);\n",
    "    assert(c_piochee->presente==false); // absence du jeu ?\n",
    "    assert(est_presente_main(main_A, *c_piochee));\n",
    "    assert(main_A.nb = mem_taille + 1);\n",
    "\n",
    "    // Affichage\n",
    "    printf(\"\\n\\n ***** APRES la pioche : \");\n",
    "    printf(\"\\n La carte piochee : \");\n",
    "    afficher_carte(*c_piochee);\n",
    "    printf(\"\\n La nouvelle main A après pioche : \\n\");\n",
    "    afficher_main(main_A);\n",
    "    printf(\"\\n Le nouveau jeu après pioche : \\n\");\n",
    "    afficher_jeu(le_jeu);\n",
    "\n",
    "    //Détruire la mémoire allouée dynamiquement\n",
    "    free(main_A.main);\n",
    "    free(main_B.main);\n",
    "    main_A.main = NULL;\n",
    "    main_B.main = NULL;\n",
    "}\n",
    "\n",
    "int main(void) {\n",
    "  \n",
    "    test_piocher();\n",
    "    \n",
    "    printf(\"%s\", \"\\n Bravo ! Tous les tests passent.\\n\");\n",
    "    return EXIT_SUCCESS;\n",
    "}\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "---\n",
    "---\n",
    "## BILAN sur l'allocation dynamique. (à rendre)\n",
    "---\n",
    "---"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### String : Chaines de caractères à la Java / C++\n",
    "\n",
    "L’objectif de ces exercices est de définir un vrai type « chaîne de caractères » appelé String par analogie avec le type correspondant des langages Java ou C++. Outre les opérations de haut niveau disponibles sur ce type, sa caractéristique essentielle est de décharger l’utilisateur de la gestion des problèmes de capacité de la chaîne. Si elle est trop petite pour faire une opération d’ajout, elle est agrandie de manière transparente pour l’utilisateur. \n",
    "\n",
    "Les opérations disponibles sur une String sont :\n",
    "- __create__ : initialiser une variable de type String à partir d’une chaîne de caractères classique (tableau de caractères terminé par le caractère nul) ;\n",
    "- __destroy__ : détruire un variable de type String. Elle ne pourra plus être utilisée (sauf à être de nouveau initialisée) ;\n",
    "- __length__ : obtenir le nombre de caractères de la chaîne ;\n",
    "- __get__ : obtenir le caractère à la position `i` de la chaîne. Le premier caractère a la position 0 ;\n",
    "- __replace__ : remplacer le caractère à la position `i` de la chaîne par un nouveau caractère ;\n",
    "- __add__ : ajouter un nouveau caractère à la fin de la chaîne. Sa longueur est donc augmentée de 1 ;\n",
    "- __append__ : ajouter une chaîne de caractères à la fin de d’une chaîne ;\n",
    "- __insert__ : ajouter un nouveau caractère en position `i` de la chaîne `str`. La longueur de la chaîne est donc augmentée de 1. La valeur de `i` doit être comprise entre 0 et `length(str)`. Si `i` vaut `length(str)`, alors `insert` se comporte comme `add` ;\n",
    "- __delete__ : supprimer le caractère à la position `i`. \n",
    "- __substring__ : retourne une nouvelle String initialisée avec la partie de la chaîne comprise entre les indices début et fin, début inclu et fin exclu.\n",
    "\n",
    "Une chaine de caractères sera définie dans ce travail comme un enregistrement d'un tableau de caractères dynamique et d'une taille.\n",
    "\n",
    "__Question__\n",
    "\n",
    "> Dans cet exercice bilan, il faut compléter l'implantation des sous-programmes `create`, `add`, `delete`, `length` et `destroy` de façon à ce que les tests s'exécutent avec succès.\n",
    "\n",
    "__RENDU__\n",
    "    Le rendu de cet exercice Bilan est attendu dans le fichier __`1SN_LangageC_C2_Bilan.c`__ via SVN."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "#include <stdlib.h>\n",
    "#include <stdio.h>\n",
    "#include <stdbool.h>\n",
    "#include <assert.h>\n",
    "#include <string.h>\n",
    "\n",
    "// Consignes :\n",
    "//      - Compléter les instructions pour réaliser les fonctions et \n",
    "//        procédures de ce fichier de façon à exécuter les tests avec succès.\n",
    "// Vous pouvez utiliser les sous-programmes de la bibliothèque string.h pour réaliser \n",
    "// les principales opérations (copie, recherche, etc.)\n",
    "\n",
    "struct string {\n",
    "    char *str; // tableau de caracteres. Doit se terminer par `\\0`.\n",
    "    int N; // nombre de caractères, `\\0` inclus.\n",
    "};\n",
    "typedef struct string string;\n",
    "\n",
    "/**\n",
    " * \\brief Initialiser à partir d’une chaîne de caractères classique \n",
    " * (tableau de caractères terminé par le caractère nul)\n",
    " * \\param[out] chaine_dest string initialisé\n",
    " * \\param[in] chaine_src chaine conventionnelle\n",
    " */\n",
    "void create(string *chaine_dest, char *chaine_src){\n",
    "    // ****** TODO *******\n",
    "}\n",
    "\n",
    "/**\n",
    " * \\brief obtenir le nombre de caractères de la chaîne\n",
    " * \\param[in] str chaine\n",
    " */\n",
    "int length(string chaine){\n",
    "    // ****** TODO *******\n",
    "    return 0;\n",
    "}\n",
    "\n",
    "/**\n",
    " * \\brief ajouter un nouveau caractère à la fin de la chaîne. Sa longueur est donc augmentée de 1.\n",
    " * \\param[inout] chaine\n",
    " * \\param[in] c le caractère à ajouter en fin de chaine.\n",
    "*/\n",
    "void add(string *chaine, char c){\n",
    "    // ****** TODO *******\n",
    "}\n",
    "\n",
    "\n",
    "/**\n",
    " * \\brief supprimer le caractère à la position i.\n",
    " * \\param[inout] chaine\n",
    " * \\param[in] i position du caractere dans la chaine \n",
    " * (attention à la precondition).\n",
    "*/\n",
    "void delete(string *chaine, int i){\n",
    "    // ****** TODO *******\n",
    "}\n",
    "\n",
    "/**\n",
    " * \\brief détruire, elle ne pourra plus être utilisée (sauf à être de nouveau initialisée)\n",
    " * \\param[in] chaine chaine à détruire\n",
    "*/\n",
    "void destroy(string *chaine){\n",
    "    // ****** TODO *******\n",
    "}\n",
    "\n",
    "\n",
    "\n",
    "void test_create(){\n",
    "    string ch, ch1, ch2;\n",
    "    create(&ch, \"UN\");\n",
    "    assert(ch.N == 3);\n",
    "    assert(ch.str[0] == 'U');\n",
    "    create(&ch1, \"DEUX\");\n",
    "    assert(ch1.N == 5);\n",
    "    assert(ch1.str[4] == '\\0');\n",
    "    create(&ch2, \"\");\n",
    "    assert(ch2.N == 1);\n",
    "    assert(ch2.str[0] == '\\0');\n",
    "    \n",
    "    destroy(&ch);\n",
    "    destroy(&ch1);\n",
    "    destroy(&ch2);\n",
    "}\n",
    "\n",
    "\n",
    "void test_length(){\n",
    "    string ch, ch1;\n",
    "    create(&ch, \"UN\");\n",
    "    assert(strlen(\"UN\")==length(ch));\n",
    "    create(&ch1, \"\");\n",
    "    assert(length(ch1)==strlen(\"\"));\n",
    "    destroy(&ch);\n",
    "    destroy(&ch1);\n",
    "}\n",
    "\n",
    "void test_add(){\n",
    "    string ch1;\n",
    "    create(&ch1, \"TROI\");\n",
    "    add(&ch1, 'S');\n",
    "    assert(length(ch1) == 5);\n",
    "    assert(ch1.str[4] == 'S');\n",
    "    add(&ch1, '+');\n",
    "    assert(length(ch1) == 6);\n",
    "    assert(ch1.str[5] == '+');\n",
    "    destroy(&ch1);\n",
    "}\n",
    "\n",
    "\n",
    "void test_delete(){\n",
    "    string ch1;\n",
    "    create(&ch1, \"TROIS\");\n",
    "    delete(&ch1, 0); //ROIS\n",
    "    assert(length(ch1) == 4);\n",
    "    assert(ch1.str[0] == 'R');\n",
    "    delete(&ch1, 2); //ROS\n",
    "    assert(length(ch1) == 3);\n",
    "    assert(ch1.str[2] == 'S');\n",
    "    delete(&ch1, 2); //RO\n",
    "    assert(length(ch1) == 2);\n",
    "    assert(ch1.str[1] == 'O');\n",
    "    delete(&ch1, 0); //O\n",
    "    delete(&ch1, 0); //_\n",
    "    assert(length(ch1) == 0);\n",
    "    \n",
    "    destroy(&ch1);\n",
    "}\n",
    "\n",
    "\n",
    "void test_destroy(){\n",
    "    string ch, ch1;\n",
    "    create(&ch, \"UN\");\n",
    "    destroy(&ch);\n",
    "    assert(ch.str == NULL);\n",
    "    \n",
    "    create(&ch1, \"TROI\");\n",
    "    add(&ch1, 'S');\n",
    "    destroy(&ch1);\n",
    "    assert(ch1.str == NULL);\n",
    "}\n",
    "\n",
    "int main(){\n",
    "    test_create();\n",
    "    test_length();\n",
    "    test_add();\n",
    "    test_delete();\n",
    "    test_destroy();\n",
    "    \n",
    "    printf(\"%s\", \"\\n Bravo ! Tous les tests passent.\\n\");\n",
    "    return EXIT_SUCCESS;\n",
    "}"
   ]
  }
 ],
 "metadata": {
  "celltoolbar": "Format de la Cellule Texte Brut",
  "kernelspec": {
   "display_name": "C",
   "language": "c",
   "name": "c"
  },
  "language_info": {
   "file_extension": ".c",
   "mimetype": "text/plain",
   "name": "c"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 4
}
